2012.01.17.15.59.43

Задание 4. Всё ещё не работает

Задание 7. Аналогично

2012.01.16.18.30.30

Задание 3. Хорошо. Но + один убираю. Ибо сообщения об ошибках типа Aaaaa - это,
	конечно, очень информативно.

Задание 4. Ну вот... А я уж было понадеялся :) Ладно, давайте разбираться.

	(1) Это не было умножением матриц, потому что при умножении всё же
		накапливается сумма. Вы это исправили.

	(2) Теперь про индексы.

		1. Квадрат - это частный случай прямоугольника. В общем случае
			плитка может быть прямоугольной, в конкретном,
			квадратной. Хорошо, мы рассматриваем квадратную.
			Чего же в этом шокирующего?

		2. А массивы никакого отношения к размерности пространства не
			имеют. Массив - это способ организации ячеек памяти
			в линейном адресном пространстве. Запись:

				A[X][Y][Z][W]

			всего лишь говорит, что в памяти, начинающейся по
			адресу A хранится X блоков,
				каждый из которых представляет собой Y блоков,
					каждый из которых состоит из Z блоков,
						каждый из которых - это кусок
						памяти, содержащий W элементов.

			Здесь нет никакой четырёхмерности. Память - штука
			одномерная, как летнда в машине Тьюринга.

			Далее, Вы правильно говорите, что всё это используется
			лишь для вычисления адреса элемента матрицы, что
			верно. И это никак не отличается от изначальной
			постановки, просто я делаю такое её уточнение.
			Изначально ожидалось, что кто-нибудь да сообразит,
			что не нужно вести сложный перерасчёт индексов и
			поручить это дело компилятору, задав матрицы
			такими вот массивами. Но народ не захотел так делать.

			Эх KISS предан забвению.

			Вот... Поэтому я при помощи такой вот записи и уточняю,
			каким должен быть перерасчёт адресов.

		3. Я считаю, что переходить к размеру тайла 1x1 можно в любом
			случае, когда матрица действительно храниться по
			тайлам. Если выражения в программе при подстановке
			такого размера тайла выдают нечто некорректное, значит,
			это не выражения, описывающие доступ к матрице,
			хранимой по тайлам. Ну, и, собственно, я сделал
			такой переход в Вашей формуле и получилось нечто
			странное.

		4. Я не понял, как Вы из того, что написано в Readme, вообще
			всего, что там написано, перешли к формуле, которая
			написана в комментариях к define f

		5. Вы зря думаете, что у меня есть монитор и шрифт, который
			позволяет верно посмотреть форматирование Вашего
			комментария. Если уж Вам нравиться писать такие
			длинные пояснения с некими двумерными геометрическими
			обоснованиями (что, кстати, очень даже хорошо, если
			делать это правильно), то неплохо бы применять для
			этого LaTeX.

		6. Но такой монитор найти не проблема, поэтому продолжим наши
			изыскания... Причина Ваших (впрочем, и моих с Вашим
			кодом :) затруднений понятна.

			Вы рассматриваете матрицу, как нечто двумерное, в то
			время, как в памяти - это просто некий кусок памяти,
			адреса при доступе к которому и надо пересчитывать,
			не знает процессор ни о каких двумерностях в структурах
			данных. Это важно понимать.

			Далее. Тот пересчёт адресов, который Вы ведёте он
			какой-то странный. Вот по какой причине. По идее,
			если сначала определять клетку в такой вот "двумерной"
			структуре, то есть, как я понял из Ваших рассуждений,
			координату её левого верхнего угла (Вы же потом
			складываете двумерные координаты, так?), а потом
			прибавить к ним координаты внутри клетки, то должны
			быть в итоге получены исходные координаты... Чего
			я в этом месте не понимаю? А я определённо чего-то
			не понимаю, потому что... У Вас какие-то трёхэтажные
			формулы.

			При этом у Вас очень странная модель вычислений.
			Сначала Вы считаете, что блоки идут друг за другом и
			вычисляете номер блока в который должен попасть
			(i;j) - ок, замечательно. 

			Затем Вы зачем-то говорите, что все эти блоки у Вас
			завёрнуты в двумерный массив и считаете координаты
			блока в этом двумерном массиве из блоков. Тут уже не
			особо понятно, зачем это делать, но допустим, в этом
			есть расход ресурсов, но пока всё корректно хотя бы.

			А потом Вы говорите, что это на самом деле не
			координаты блока в двумерном массиве блоков, а
			двумерные координаты левого верхнего угла блока в
			двумерном массиве из элементов.

			Ну хорошо. Я не знаю, почему Вам было сложно эти
			координаты посчитать как (i/T2;j/T1) (и если вы
			свои формулы упростите, так оно и выйдет в итоге).
			Но, допустим, Вы это посчитали.

			Но затем, Вы применяете какую-то авторскую процедуру
			упаковки оставшихся элементов в эту свою двумерную
			дырявую (разные строки этой клетки будут разбросаны
			по памяти) структуру памяти.

			Не удивительно, что это Вам кажется извращением,
			потому что это и есть извращение. Однако, автор его
			Вы :)

		7. Вы бы вместо пространных писем взяли бы, да
			протестировали бы, результаты возведения в квадрат
			единичной матрицы :) Почему-то matrix в результате
			выдаёт нулевую матрицу, а matrix2 - единичную.
			Теоретически, это должно было бы Вас насторожить.

		8. Тайлы - это не клетки в двумерной матрице, которые являются
			по сути, наборами отрезков в памяти, это НЕПРЕРЫВНЫЕ
			куски в памяти, на которые разбивается матрица. У Вас
			же не тайлы, а какая-то непонятная геометрия. Может,
			конечно, в ней есть некий классный физический смысл,
			множество открытий совершались случайно. Но к
			решению данной, конкретной задачи, это отношения
			не имеет. А моя цель в данном случае научить вашу
			группу хоть немного представлять, как оно там в
			памяти всё раскладывается.

			Вот здесь вот

				A[M/T2][N/T1]([T2][T1])

			непрерывным куском памяти является взятое в ().

Задание 7. Запускаю, вижу ситуацию, прозванную на практиках Апокалипсисом -
	постоянные перезагрузки.

2012.01.13.23.56.43

Я верно понимаю, что изменений по предыдущим заданиям нет?

Задание 7. Так, во-первых, не требовалась же качественная реализация rand. А
	просто хоть какая-то. Кроме того, glibc же есть в исходниках и
	комментатриях. Например, описание random есть здесь:

		http://www.mscs.dal.ca/~selinger/random/

	По вопросу с прерываниями. Можно же взять ассемблер и посмотреть, что
	у всех видов iret одинаковый код: CF. Дело не в этом.

	И есть у меня ощущение, что Вы не особо верно загружаете IDT. Почему
	ebx + 2?

	Плюс к этому есть ещё один минус.

	(1) Не компилируется Ваш код на 64-битной системы

		$ sh 1.sh 
		In file included from /usr/include/features.h:382:0,
		from /usr/include/stdlib.h:25,
		from 1.c:7:
		/usr/include/gnu/stubs.h:7:27: fatal error: gnu/stubs-32.h: No such file or directory
		compilation terminated.

		stubs-32.h - это определения для типов, вроде uint32_t и тому
		подобных радостей. У Вас эти определения сделаны вручную, что
		не так уж и плохо, но этот файл тянется за stdlib, от которой
		надо бы избавится. Мы же пишем как бы ядро OS, там не может
		быть libc.


2012.01.11.18.18.25

Общее такое замечание ко всем исходным текстам. Существует typedef специально
для определения типов, define для этого лучше не использовать, потому что
могут возникнуть проблемы, когда, например, в библиотеке уже определён тип
uint, а препроцессор будет сносить этой библиотеке логику, заменяя его на
нечто неожиданное.

Если вы используете define для выражений, то эти выражения надо брать в скобки,
потому что нет гарантий, что приоритеты оператора внутри такого выражения
перевесят приоритеты операторов, которые стоят снаружи от обращения к
макросу.

Задание 1. ОК.

Задание 2. ОК.

Задание 3. Вроде, лучше. Но

	(1) Ошибки. Если вот это
		
		read=fread(buffer, 1, 30720, fp);

		вернёт -1, будет очень весело дальше. Если что-то не допишется
		в файл, тоже будет праздник отладки. И что будет, если сектора
		не загрузятся? И так далее.

	(2) Не все x86 процессоры могут выполнять 32-битовый код. Если Вы его
		используете, то нужно сначала проверить, что процессор на
		это способен. Проверить можно таким кодом:

		;--------i8086,i286------------
		pushf
		pop ax
		and ax,0F000h
		cmp ax,0
		je i286
		cmp ax,0F000h
		je i8086
		;------i386---------------------

Задание 4. Оно, конечно, не было указано, как именно следует инициализировать
	матрицы, но захотелось напомнить, что memset работает с байтами.
	Это не минус, просто напоминание. Минусы вот:

	(1) Ваш код совсем не умножает матрицы.

	(2) Плитка может быть любого размера, и она является просто
		прямоугольной таблицей из элементов матрицы, которая составлена
		из этих прямоугольников. То есть, структура примерно такая:

			A[N/TX][M/TY][TX][TY] // для простоты всё кратное.

		Если TX = TY = 1, то получаем обычную матрицу, хранимую
		по строкам.

		У Вас же как-то странно получается, когда T = 1. Если
		подставить сюда:

			buf[ T*(i/T) + j/T ] [T*(i%T)+j%T]

		То получится

			buf[i + j][0]

		Не очень похоже на матрицу, потому что для разных i и j
		могут ([3;5] == [5;3]) выбираться одинаковые элементы.

		Оно у Вас, вроде, должно работать, для тех размеров, которые Вы
		используете, но хотелось бы более общего алгоритма, чтобы
		можно было произвольно эти размеры менять.

		Плюс я не понял Ваш комментарий. Смысл всего этого плиточного
		подхода как раз в том, чтобы при смене номера строки матрицы
		(i) не приходилось перепрыгивать на другую страницу памяти,
		и в формуле, которая у Вас в программе так и происходит. Но
		формула, которая в readme.txt, совсем не такая. И как Вы от
		одной перешли к другой, для меня загадка.

Задание 6. Нормально, но в следующий раз надо учитывать, что компиляция может
	происходить совсем не на той системе, о которой Вы подумали. Поэтому,
	нужно достаточно точно указывать для gcc и ld целевую архитектуру.
	При решении 7-ой задачи обязательно нужно будет использовать ключи:

		gcc: -m32 -march=i386
		ld: -m elf_i686 --oformat=elf32-i386

	(1) Эх... Лихие люди в Вашей группе. Вот переводите Вы роцессор в
		защищённый режим, структуры у него никакие не настроены,
		сегменты тоже, адреса - каша. И тут прилетает Вам прерывание.
		И всё. Ядерный реактор взорвался.

		Почему cli не используется на время смены режима работы
		процессора?

		Ядерный реактор в опасности. Это двойной минус.

2012.01.01.19.18.16

Без изменений.

2011.12.27.19.12.14

Без изменений

2011.12.25.15.25.48

Задание 0. Ладно. Минусы я уберу, но output.txt тоже не нужно было оставлять
	в хранилище.

Задание 1. Нет, ну goto - это, конечно, не страшно. Но первый же
	goto EndReadFile вполне можно заменить на break. И надо бы это сделать.

	Но вот настоящие замечания:

	(1) А что будет, если строка будет длиннее 1000 байтов? Это суровый
		баг у Вас с переполнением буфера на пару минусов.

Задание 2. Я так понимаю, что никаких изменений в коде? И всё равно остаются
	вопросы:

	(1) Зачем считать по модулю 511, если можно считать по модулю 512, что
		намного эффективнее. У Вас же, в общем-то, не получается
		экономии одного байта на этом: Вы всё равно считываете его,
		просто в другую переменную. Ну, а за счёт более сложных
		алгоритмов на код память тоже расходуется. 

	(2) По-прежнему, Вы ищете только одну сигнатуру.

	(3) Существуют же функции fread и fwrite.

	(4) Нужно добавить дизассемблированный загрузочный сектор в хранилище.

Задание 3. Не понятно, чем Вам так tasm нравится? Очень же старый ассемблер,
	который специально предназначен для программирования под DOS и
	Windows, а совсем не для системного программирования. Но раз вам
	нравится пересчитывать адреса... Ладно.

	Но возникает вопрос, а зачем Вы тогда пишете так:

		lea si, buf
		add si, 7b00h

	вместо того, чтобы писать так:

		lea si, [buf + 7b00h]

	Ну и минусы

	(1) Нужно сделать CRC32

	(2) И что за магические циферки Вы исправляете в buf?

	(3) Нужно же передавать управление на загружаемый код, а не просто
		распечатывать данные.

2011.12.05.15.58.12

Без изменений.

2011.12.03.10.27.17

Задача 0.

Много минусов за каждый файл не относящийся к исходным текстам. Зачем их
включать в хранилище? Во-первых, они занимают много места не понятно, с какой
целью, потому что просто получаются из исходных текстов. Во-вторых, с высокой
вероятностью не будут работать на машине другого человека: зачем мне
.exe-шник, если у меня Linux, и зачем мне

	$ file make_boot
	make_boot: ELF 32-bit LSB executable, Intel 80386

если у меня процессор архитектуры ARM? Всё это надо безжалостно вычистить из
хранилища, воспользовавшись командой filter-branch с опцией --tree-filter, о
которой можно прочитать здесь:

	http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/ch05.html	

Задача 1.

Воспользоваться для вывода stdout - это хорошо. Но...

(1) Нужно прочитать числа из всех файлов, и все их вместе отсортировать, а не
сортировать каждый файл отдельно.

(2) Некорректный формат одного из файлов не должен приводить к фатальному
сбою приложения: есть другие данные, с которыми надо работать.

(3) Ограничение в 100 чисел - это уж слишком для данной задачи. Программа
должна работать, пока ей хватает памяти для работы. Можно использовать realloc
для динамической подстройки размера буфера под количество чисел.

Задача 2.

(1) Почему у вас вычисления осуществляются по модулю 511? Почему не взять
512-байтовый буфер? Вычисления по модулю степени двойки гораздо эффективнее. И
вполне приемлемы для данной задачи.

И зачем такая сложная логика? Ведь, существует возможность отмотать файл назад:

	fseek(file, -512, SEEK_SET);

После того, как Вы обнаружите в потоке два байта сигнатуры.

(2) Почему предполагается в программе, что 0x55 0xaa может встретится только
в конце загрузочного сектора? Образ диска - штука большая и сложная и это
значение может оказаться на любом месте. Нужно найти всех кандидатов на
загрузочный сектор, а потом выбрать один из них, попробовав дизассемблировать.

(3) В хранилище нужно разместить листинг загрузочного сектора.

Задача 3.

Дополнительный плюс, конечно, за попытку воспользоваться системными вызовами
Linux. Но хотелось бы всё же, чтобы программа не только завершалась, но и
выводила результат вычисления на экран.
