2011.12.22.13.38.16

Задание 0. Оно связано с искусством владения Git, поэтому переношу сюда
	минусы за бинарные файлы в хранилище, которые надо бы почистить.

	(1) task2/bin123

	(2) task3/1, task3/asm/1, task3/asm/2

	(3) task4/cw

Задание 1. 

	(1) А почему у вас i равное argc-1 обрабатывается в цикле?

	(2) И всё то же замечание про try-catch внутри цикла.

Задание 2.

	(1) По-прежнему в программе предполагается, что заканчивающийся на 0x55
	0xaa сектор может быть лишь один в образе диска. Но это может быть и не
	так.

Задание 3. Уже лучше. Но, как-то, очень сурово и хардкорно у Вас. Не знаю,
	не уверен, что в данном случае эта хардкорность оправдана. С одной
	стороны, мне хочется за Ваше решение поставить дополнительный плюс, а с
	другой - нет от него ощущения надёжности. Наверное так: если баллов
	хватать не будет до автомата, то поставлю здесь Вам плюс. А пока - нет.

	Ну. И есть недочёты, с которыми остаётся справится

	(1) Надо посчитать CRC32.

	(2) Надо не просто напечатать загруженный текст, а передать управление
	на загруженный код.

Задание 4. У меня только обычное умножение матриц. Потерялся второй файл?

Задание 5. Хорошо.

Задание 6. Замечательно. Только вот:

	(1) Makefile всё же надо бы сделать подеревяннее. В том смысле, что
		надо бы не в одном правиле всё собирать, а по кусочкам. Тем
		более, у Вас же в "f" есть неплохой пример.

	(2) Обработка ошибок

Задание 7.

2011.12.05.14.01.35

Без изменений.

2011.12.02.12.08.42

Задача 1.

(1) А что если в команде будет указано только имя программы и всё?
А если будет указан только один файл? Надо аккуратнее разобраться с argc.

(2) Разве есть необходимость использовать в этой задаче глобальную память?
vector и vector::iterator - это же, в общем-то, ссылочные объекты. Стек на них
не будет сильно расходоваться.

(3) Цикл в строках 23-37 не очень хорош. Потому что, если память закончится,
то бесполезно повторять попытки записать новое значение в вектор, ведь,
в свободное место магическим образом не появится. В итоге, будут выданы
100500 сообщений об ошибке.

Кроме этого, try-catch внутри цикла - это не самое эффективное решение. Тут
разумнее весь цикл разместить внутри try-catch (с философских позиций нужно же
ловить исключительные ситуации в процессе работы всего алгоритма, а не
какой-то мелкой его части).

(4) Это не замечание, а просто такой вопрос: Вы уже второй, кто использует
stdio при программировании на С++, почему? Чем плох iostream?

Задача 2.

(1) IDA - это круто, конечно. Но полученный ассемблерный код явно некорректный.
Ведь, загрузочный сектор - это 16-битовый код, а в полученном Вами листинге
встречаются инструкции типа:

	mov esp, <32-битовое значение>

Так не должно быть.

(2) Не совсем корректно предполагать, что во всём образе диска
последовательность 0x55 0xaa встретится только один раз и только для
загрузочного сектора. Нужно отыскать все такие сигнатуры.

Задача 3.

(1) Эх, я понимаю, конечно, что Perl, но, ведь, это плохая практика писать if
(тем более важный, который относится к анализу входных данных) в конце
выражения. Минус за это, код должен быть читаемым даже в редакторе без
подсветки синтаксиса.

(2 и 3) Ух. Когда вы занимаетесь накладыванием заплаток на бинарные данные,
нужны комментарии. Что такое l1 и l2? Почему они записываются в два разных
места? Почему длина не сохраняется? Почему l1 и l2 - это результаты деления
с остатком на 256? Неплохо бы было это всё прокомментировать. И добавит ещё
ассемблерный код для используемого загрузочного сектора.

Задача 4. Здесь вот точно не нужно бинарные файлы включать в хранилище.  Надо
почистить. Смотрите про использование filter-branch --tree-filter в руководстве
Git Magic

	http://dl.dropbox.com/u/281916/delete/book.pdf
