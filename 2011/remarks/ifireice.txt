2012.01.23.20.18.49

Задание 0. ОК

Задание 1. Я не такой уж эксперт по Perl. Но, мне кажется, что внесённые
	изменения, это не то, что требуется. Ведь, память может закончится
	при накоплении данных в переменной $msg. То есть, безконтрольно
	вылететь из процесса обработки можно задолго до выполнения eval.

	Ну. И оно по-прежнему без проблем делает нечто с файлом 1.txt, хотя,
	вроде, по постановке задачи не должно. Видимо, что-то не так с
	regexp-ом.

Задание 2. Ой. Я в прошлый раз, видимо, проглядел строчку $output ++. Прошу
	прощения. Компенсирю дополнительным плюсиком.

Задание 3. Ну да... Хороший код. Только вот есть в нём ошибка при обращении
	к int 0x13. Номер же головки не указан.

Задание 6.

	(1) Ну вот почему предполагается, что ds и es в реальном режиме
		работы процессора надо настраивать с запретом прерываний,
		чтобы какое-нибудь нетерпеливое устройство не вынесло мозг
		системе. А вот при переходе в защищённый режим можно
		без этого обойтись?

2012.01.19.02.57.19

Задание 0. А у нас тут такая система оценки, основанная на том, что в
	хранилище не должно быть двоичных файлов и чего-либо не относящегося
	к исходным текстам. А у Вас двоичные файлы.

	$ git log -p | grep Bin
	Binary files a/4/M_T.out and b/4/M_T.out differ
	Binary files /dev/null and b/4/M_T.out differ
	Binary files /dev/null and b/4/Matrix differ
	Binary files /dev/null and b/4/a.out differ
	Binary files /dev/null and b/2/3 differ

	Инструкция по борьбе с ними есть, например, в scraftworld.txt,
	они больше всех по этим граблям ходили.

	Поэтому, в итоге набегает 4 минуса здесь.

Задание 1. Ой. Программа же совсем не обрабатывает ошибки и не реагирует на
	файлы не того формата.

	$ perl SortNumber.pl 1.txt 2

	Сработало, выдала какой-то результат, явно состоящий не из одних чисел.
	
	Ну... И эту программу надо было писать на Си/Си++. Это неявно указано в
	условии (fscanf). Хотя, наверное, можно и на Perl, только я не знаю,
	как в нём можно обработать переполнение памяти, допустим. А это надо
	учесть. Хотя, можно сделать через процесс дополнительный. Если
	процессу не хватает памяти, то он аварийно завершается и не
	возвращает нулевой код возврата.

	Если сделаете на perl такую схему, будут дополнительные плюсики. А
	пока, ну... Программа не решает поставленную задачу.

Задание 2. Эх. В целом не плохо. Лаконично, всё такое. Это ценно. Но с
	другой стороны...

	(1) Как же так? Вы всё время открываете один и тот же файл, и всё
		время его перезаписываете. Как же у Вас тогда вообще оказался
		код загрузочного сектора? Ведь, этот самый код при выполнении
		Вашей программы перезаписывается несколько раз.

		Мистика...

		Добавьте, пожалуйста, в хранилище результат дизассемблирования
		нескольких первых кандидатов в загрузочные секторы.

Задание 4. Красиво и аккуратно.

Задание 5. Аналогично.
