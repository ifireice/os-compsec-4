2011.12.27.16.09.41

Задание 1. Да, он нормально работает с одним файлом. Но, получается, что
	уничтожается содержимое файла последнего. Надо тогда выводить сообщение
	большими буквами: ФАЙЛ X БУДЕТ ПЕРЕЗАПИСАН и вопрос пользователю
	задавать, хочет он этого или нет.

	Но обычно не принято исходные файлы перезаписывать, если это явно
	как-то не указано при помощи специальной опции, типа --force. Да и
	защищён исходный файл может быть от записи.

	Вот какая куча недостатков. Ну да ладно. Надеюсь, Вы это осознаете и
	больше так делать не будете.

Задание 2. Ладно, не плохо. Но...
	
	(1) Perl же умеет читать из файлов целые куски и куски же записывать:
		read/write. Посимвольно - это не очень хорошо. Или даже очень
		не хорошо.

	(2) Ошибки же! Бывают не только при открытии и закрытии.

Задание 3.

	(1) Надо передать управление не код.

	(2) Проверка на тип процессора не правильно сделана. Вы проверяете,
		на самом деле, в какую именно инструкцию ассемблер
		оттранслировал pushfd. Это может быть либо 9C, либо 66 9C
		(66 префикс для определения размерности). Но процессор
		может и не знать инструкции 66 9C, и она пошлёт его в аут.
		Правильная проверка должна быть примерно такая:

		;--------i8086,i286------------
		pushf
		pop ax
		and ax,0F000h
		cmp ax,0
		je i286
		cmp ax,0F000h
		je i8086
		;------i386---------------------
		pushfd


Задание 4. Хорошо то, что есть тесты, и что всё в одном файле, и матрицы
	одинаковые. Но всё же.

	(1) А почему cou так странно расчитывается? Допустим, если sT = 0,
		то есть, размер тайла 1x1, то получится нечто некорректное.

	(2) А является ли описанный алгоритм умножением матриц? Можно же
		посчитать количество итераций, затрачиваемых на вычисление
		одного элемента в матрице C.

		Для разных x и у всегда будут разные x1 и y1, значит, это
		количество определяется только тремя внутренними циклами.

		Для разных i и j тоже будут всегда разные элементы c
		рассматриваться. Значит, количество операций определяется
		диапазонами для i2 и il. А они в произведении не дают 1 << size.

		Кроме того, смысл хранения по tile-ам он в том, чтобы при
		переходе через строку матрицы b оставаться в том же самом
		линейном небольшом участке памяти, а у Вас всё-равно будет
		переход через длинную строку матрицы b.

		Вообще, проще всего всю эту арифметику пересчитать, если
		предполагать, что элемент матрицы A(i,j), где сама матрица
		имеет вид

			A[N/tn][M/tm][tn][tm] // тайл размером tn на tm

		находится по адресу

			A[i/tn][j/tm][i%tn][j%tm]

Задание 6. То же самое замечание о флагах для gcc (куда он делся?) и ld

	(1) Обработка ошибок

	(2) Makefile

	(3) Только сейчас заметил - не сделан cli для перевода процессора в
		защищённый режим.

Задание 7. Повторюсь. Видимо, эффекта нет от того, что компилятор просто не
	вставляет в код инструкции для вычисления 

		int a= 2/0;

	Но можно уже и недочёты упомянуть.

	(1) Нужно использовать загрузчик из задания 3.

	(2) Всё-таки, для этой задачи уже надо бы использовать настройку
		компилятора Си на верную архитектуру процессора. В задании 6
		это простительно, там мало всего, и я могу написать их для
		проверки вручную. Но здесь много модулей, и это должно быть
		автоматизировано. Для GCC нужно бы дописать

			gcc -m32 -march=i386

		для LD:

			ld --oformat elf32_i386 -m elf_i386

	Кроме этого пока не понятно, но учтите, что в interrupt.s немного
	неверная модель описана происходящего. При переходе из Ring0 в Ring0,
	как в случае для этой задачи, SS:ESP в стек не записываются. Это надо
	учесть.

2011.12.22.13.38.16

Задание 0. Оно связано с искусством владения Git, поэтому переношу сюда
	минусы за бинарные файлы в хранилище, которые надо бы почистить.

	(1) task2/bin123

	(2) task3/1, task3/asm/1, task3/asm/2

	(3) task4/cw

Задание 1. 

	(1) А почему у вас i равное argc-1 обрабатывается в цикле?

	(2) И всё то же замечание про try-catch внутри цикла.

Задание 2.

	(1) По-прежнему в программе предполагается, что заканчивающийся на 0x55
	0xaa сектор может быть лишь один в образе диска. Но это может быть и не
	так.

Задание 3. Уже лучше. Но, как-то, очень сурово и хардкорно у Вас. Не знаю,
	не уверен, что в данном случае эта хардкорность оправдана. С одной
	стороны, мне хочется за Ваше решение поставить дополнительный плюс, а с
	другой - нет от него ощущения надёжности. Наверное так: если баллов
	хватать не будет до автомата, то поставлю здесь Вам плюс. А пока - нет.

	Ну. И есть недочёты, с которыми остаётся справится

	(1) Надо посчитать CRC32.

	(2) Надо не просто напечатать загруженный текст, а передать управление
		на загруженный код.

Задание 4. У меня только обычное умножение матриц. Потерялся второй файл?

Задание 5. Хорошо.

Задание 6. Замечательно. Только вот:

	(1) Makefile всё же надо бы сделать подеревяннее. В том смысле, что
		надо бы не в одном правиле всё собирать, а по кусочкам. Тем
		более, у Вас же в "f" есть неплохой пример.

	(2) Обработка ошибок

Задание 7.

2011.12.05.14.01.35

Без изменений.

2011.12.02.12.08.42

Задача 1.

(1) А что если в команде будет указано только имя программы и всё?
А если будет указан только один файл? Надо аккуратнее разобраться с argc.

(2) Разве есть необходимость использовать в этой задаче глобальную память?
vector и vector::iterator - это же, в общем-то, ссылочные объекты. Стек на них
не будет сильно расходоваться.

(3) Цикл в строках 23-37 не очень хорош. Потому что, если память закончится,
то бесполезно повторять попытки записать новое значение в вектор, ведь,
в свободное место магическим образом не появится. В итоге, будут выданы
100500 сообщений об ошибке.

Кроме этого, try-catch внутри цикла - это не самое эффективное решение. Тут
разумнее весь цикл разместить внутри try-catch (с философских позиций нужно же
ловить исключительные ситуации в процессе работы всего алгоритма, а не
какой-то мелкой его части).

(4) Это не замечание, а просто такой вопрос: Вы уже второй, кто использует
stdio при программировании на С++, почему? Чем плох iostream?

Задача 2.

(1) IDA - это круто, конечно. Но полученный ассемблерный код явно некорректный.
Ведь, загрузочный сектор - это 16-битовый код, а в полученном Вами листинге
встречаются инструкции типа:

	mov esp, <32-битовое значение>

Так не должно быть.

(2) Не совсем корректно предполагать, что во всём образе диска
последовательность 0x55 0xaa встретится только один раз и только для
загрузочного сектора. Нужно отыскать все такие сигнатуры.

Задача 3.

(1) Эх, я понимаю, конечно, что Perl, но, ведь, это плохая практика писать if
(тем более важный, который относится к анализу входных данных) в конце
выражения. Минус за это, код должен быть читаемым даже в редакторе без
подсветки синтаксиса.

(2 и 3) Ух. Когда вы занимаетесь накладыванием заплаток на бинарные данные,
нужны комментарии. Что такое l1 и l2? Почему они записываются в два разных
места? Почему длина не сохраняется? Почему l1 и l2 - это результаты деления
с остатком на 256? Неплохо бы было это всё прокомментировать. И добавит ещё
ассемблерный код для используемого загрузочного сектора.

Задача 4. Здесь вот точно не нужно бинарные файлы включать в хранилище.  Надо
почистить. Смотрите про использование filter-branch --tree-filter в руководстве
Git Magic

	http://dl.dropbox.com/u/281916/delete/book.pdf
