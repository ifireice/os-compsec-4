2011.05.18.15.49.41

Задача 2. Как-то она странно себя ведёт. Задание, ведь было в том, чтобы
по получению сигнала выдать номер процесса (свой собственный pid) и номер
группы, в которую входит этот процесс (свой собственный pgid).

2011.05.28.11.38.46

Задачи 5. А у меня опять не компилируется:

	$ g++ -O3 dekker.cpp -o dkr 
	dekker.cpp: In function ‘void* dekker(int)’:
	dekker.cpp:37:23: error: too few arguments to function ‘void critical_function(int)’
	dekker.cpp:12:7: note: declared here
	dekker.cpp:41:20: error: too many arguments to function ‘void mfence_c()’
	dekker.cpp:17:6: note: declared here
	dekker.cpp: In function ‘int main()’:
	dekker.cpp:51:51: error: invalid conversion from ‘void* (*)(int)’ to ‘void* (*)(void*)’ [-fpermissive]
	/usr/include/pthread.h:225:12: error:   initializing argument 3 of ‘int pthread_create(pthread_t*, const pthread_attr_t*, void* (*)(void*), void*)’ [-fpermissive]
	dekker.cpp:58:47: error: invalid conversion from ‘void* (*)(int)’ to ‘void* (*)(void*)’ [-fpermissive]
	/usr/include/pthread.h:225:12: error:   initializing argument 3 of ‘int pthread_create(pthread_t*, const pthread_attr_t*, void* (*)(void*), void*)’ [-fpermissive]
	dekker.cpp:58:47: error: invalid conversion from ‘int’ to ‘void*’ [-fpermissive]
	/usr/include/pthread.h:225:12: error:   initializing argument 4 of ‘int pthread_create(pthread_t*, const pthread_attr_t*, void* (*)(void*), void*)’ [-fpermissive]

И ещё одна проблема: почему dekker_without_mfence - это .h файл? Компилятор
такого не понимает.

Но это только лишь во-первых. Во-вторых, посмотрите, пожалуйста, что Вам выдаст
после компиляции кода без mfence компилятор. Посмотреть можно так:

	g++ -O3 -S -masm=intel имя-файла.cpp -o имя-файла.asm

Из этого должно быть понятно, что у Вас пока не совсем алгоритм Деккера
написан, для которого очень важно, что обращения происходят именно к ячейкам
памяти.

В третьих, почему именно так расставлен mfence? И вообще, зачем именно нужно
ставить mfence?

Задача 3. Хм. Нет, оно, конечно, всё красиво и почти замечательно. Но... Эх.
Но что ж в Вашей группе такая нелюбовь к операционным системам? Их же
специально пишут для всякой синхронизации между процессами, но нет, многие из
вас используют флаги.

Но мы же обсуждали, что это не будет работать. 100 процессов (среди которых
тот, который выполняет process()), обращаются к flag. 99 хотят записать
туда false, а этот 1 читает, чтобы проверить fr.

Ну. Замечательно. Этот 1 видит там true, а другие устанавливают его в false,
и всё ломается.

Более того, если всё здесь не сломается, то когда дело дойдёт до освобождения
в client_handler, то когда он сделает value->release(), то буфер будет сочтён
освобождённым, но ещё же 98 клиентов выводят эти данные.

Схему взаимодействия надо переписать.
