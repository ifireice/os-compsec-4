2011.05.18.16.04.58

Задача 2.

2011.05.26.12.49.12

Задача 5 и 5.(+1). Не компилируются обе с одинаковой ошибкой:

	$ gcc -O3 dekker_mfence.c -D_GNU_SOURCE -o dmf -lrt -lpthread	
	dekker_mfence.c: In function ‘proc1’:
	dekker_mfence.c:14:1: error: parameter name omitted
	dekker_mfence.c: In function ‘proc2’:
	dekker_mfence.c:41:1: error: parameter name omitted

Задача 5. Ещё проблема: она зависает - почему?

2011.05.28.15.07.30

Задача 3. Ух... Множество вопросов.

1. Зачем постоянно переконфигурировать терминал? Но это ладно. Терминалами
мы не занимались, хто Ваше личное творчество. Однако на будущее: не нужно так
поступать. Это и не эффективно, и может к ошибкам приводить.

2. Вообще совсем не понятны рассуждения о том, зачем Вам понадобился mutex.
Кэши, вообще-то, синхронизируются автоматически. А если Вам нужно было
убеждаться, что информация о записи в переменную дошла до другого процессора,
то для этого есть mfence.

3. Эх. perror тоже пишет в stderr. Поэтому нет смысла писать

	if(fprintf (stderr, "%s\n","i can't unlock mutex")==-1) {
		perror(printfErrorMessage);
	}

Если первое не сработало, то второе тоже не сработает. И вообще у Вас код
очень сложный, а эти конструкции, одинаковые, постоянно повторяются.
Почему нельзя это всё было в виде отдельной функции оформить?

4. Ну вот право же. Зачем такая гиперсложная система? Нити, сигналы, активные
ожидания. К чему это всё? Это же пустое усложнение. А специально усложнять и
без того сложные системы - это разве разумно? Зачем Вам это?

Плюс куча ошибок в этих черезмерно усложнённых потоках данных. Вот это Вам
зачем?

	key='q';
	lock=ask;
	pthread_exit(&bad);

Это типа такой изящный способ завесить второй поток, который крутится в
while(lock == ask)? И вообще всю программу, потому что join не завершится? Так
написали бы сразу же while(true); и не мучались бы.

5. А сигналы? Эх. Отдельная песня. Вот делаете вы pthread_exit, а сигнал
оставляете старым. Программа висит, таймер тикает, пересчёт вызывается,
загрузка процессора 100% - это вы специально решили помочь системным
администраторам сварить кофе на процессоре?

6. И я что-то не вижу доказательства того, что обработчик сигнала увидит,
что lock изменился. Каким образом Вы гарантируете, что сигнал не вызовется,
во время того, что вы делаете

	lock = current

и что

	if(next == lock)

Будет отражать тот ход выполнения, который Вы запланировали? Почему lock
обработчик увидит обязательно вот этот, изменённый, а не старый? И не снесёт
тем самым тот буффер, который печатается в данный момент.

7. Из-за излишней сложности, вероятно, в программе ещё куча ошибок. Но сначала
исправьте хотя бы эти. И заметьте, я тут пока вообще ничего не написал про
активное ожидание. Кроме тех слов о гремучей смеси кучи различных подходов
в том месте, где хватило бы одного из них.

2011.05.29.18.01.52

Задачи 5.(+1) и 5. Вы программы пишете не на опциях компилятора, а на языке
программирования. Кто сказал, то в каком-нибудь компиляторе вообще -O0 будет?
Исправьте исходный код

И НЕТ, она виснет. А. Ну вот. Теперь не виснет. volatile занял своё законное
место. Ну и? К чему было спорить? И компилировать без оптимизации, если
проблема решается всего лишь этой строчкой кода? Мда...

Задача 3. Мда... Печалька :( Знаете, такая яростная уверенность в собственных
заблуждениях она же для успешной практики программирования очень даже и вредна.
Относитесь к своей точке зрения более критично, и наступит Вам, если и не
счастье, то хотя бы отсутствие проблем во многих случаях.

re re 1:
Ну и при чём тут основное моё возражение? Я же писал не о том, что терминал
перенастраивать плохо, а о том: зачем это делать каждый раз? Неужели нельзя
его перевести в посимвольный режим в начале работы программы, а потом
вернуть ему прежнее состояние в конце? О каком realtime может идти речь с таким
обращением с ресурсами? Можно же возвращение режима работы терминала занести
при помощи atexit (см. man atexit) на стадию завершения процесса.

re re 2:
Вы очень-очень сильно заблуждаетесь на счёт того, что делает инструкция mfence.
И очень-очень наивно полагаете, что барьеры памяти не используются в реализации
примитивов синхронизации в ядре ОС. Откуда Вы достали такое... хм...
оригинальное определение mfence? Почему-то вот фирма Intel с Вами не согласна,
и почему-то её инженеры полагают, что mfence - это инструкция, которая
всего лишь гарантирует упорядоченность обращений к памяти, и никаких
'протуханий' и простоев не вызывает.

re re 3:
Странно, что другие студенты такую "школу" не прошли. Я говорил лишь о том,
что надо попытаться пользователю выдать сообщение об ошибке. Раньше на это
внимание не обращал, потому что программы были проще, и это не мешало в них
разбираться. Сейчас же, ну... В глаза бросается эта дополнительная сложность.
Понятное дело, что одно fprintf хватит в данном случае.

re re 4:
Я ж Вам описал сценарий, при котором программа зависнет. А Вы спрашиваете:
неужели мне не нравится, что она корректно завершается? Да не завершится она
корректно, если вот в этом месте произойдёт сбой. Сценарий такого зависания
я Вам указал. Докажите, что он не будет никогда иметь места быть, сниму тогда
свои претензии.

re re 5:
Так дела в том, что для вашего кода есть куча цепочек исполнения, в ходе
которых программа зависает в одном из циклов ожидания, и никакие ресурсы не
будут освобождаться, потому что процесс не завершится.

re re 6:
Да при чём тут пул нитей? Сигналы всегда так работают, вызываются без
всякого согласования с основным потоком исполнения программы, если
дополнительно не устраивать синхронизацию при помощи sigsuspend и прочих
вызвов этого семейства. Присваивания действительно атомарные, и проблема совсем
не в этом.

Мда. :( Ещё большая печалька :( Теперь Вы устроили потенциальный deadlock в
обработчике сигнала. Задумайтесь, что будет, если в buildLife сработает
pthread_mutex_lock, а потом вызовется обработчик сигнала? Я же специально
рассказывал, почему это всё ведёт к проблемам.

У Вас уже есть Ваши 6 баллов, достаточные для допуска, я больше не буду
проверять Ваши коды, это отнимает слишком много времени и не приносит пользы, а
нужно и другие работы проверять. Но должен Вам сказать, что с системным
программированием и представлениями о том, как работают процессоры и ОС, совсем
не замечательно у Вас, почитайте дополнительно на этот счёт какую-нибудь
литературу.


