Задача 4. Ну вот... Куда jmp побежал-то? Сначала же верно было: сразу после включения protected mode. 

2011.01.26.12.41.58

Задачка номер 2. Всё равно. Подсчитывать количество чисел в файле, а потом заново его перечитывать - это плохой подход. И медленно, и не аккуратно, и не будет работать, если вместо файла подаётся поток данных, в котором чисел, потенциально, бесконечно много. На таком потоке Ваша программа просто зависнет.

Надо бы использовать realloc, как я и говорил.

4. Ну зачем там (38 строка) короткий jmp? Близкий переход не перегружает CS, а это то, что нужно сделать. И почему protected mode включается таким образом? Это legacy-инструкция, оставшаяся от i286. Оно работает, конечно. Но всё равно у меня вопрос: а почему не используется mov cr0, eax?

Кроме того. Нужно учитывать, что в некоторых прерываниях, процессор записывает код ошибки в стек. В этой задаче это не влияет на оценку, но вот в задачах про клавиатуру это надо учитывать.

Здесь же надо короткий jmp исправить на длинный: jmp новый-cs:xyz

5. Задача про линию кэша. Вы зря полагаете, что компилятор не сообразит (*a) разместить в регистре. Современные компиляторы очень много шаблонов знают и умеют их использовать. Поэтому и времена в результате у Вас получились близкие. Надо массив описать как volatile.

8. PIC. Всё же нужно бы иметь разные обработчики для разных типов прерываний. И ещё: а почему у Вас нет сигнала о завершении обработки прерывания PIC'у?

2011.05.18.15.11.03

Задача 2. Эх. Ну зачем так сложно? Кроме того, зачем опять эти циклы опроса?
Под Вашим приложением же целый UNIX с неплохими планировщиками, зачем
опрашивать состояние pipe, если можно просто уснуть на read?

	char chr;
	read(p0, 1, &chr);

Задача 3. У Вас же нити в программе, зачем всё делать через pipe? Да и вообще,
копирование в этой задаче - плохое решение проблемы по управлению буферами.
Тем более, в такой, построчной форме. Что будет, если терминал у пользователя
медленный? printf может начать работать очень долго, внутренний буфер pipe
будет переполнен, и временные рамки для расчёта будут нарушены.

А ещё вопрос: зачем Вы в клиентской нити 'щупаете' заполненность нити через
ioctl? Можно же просто read сделать. Вообще, экономия на системных вызовах -
это хороший тон.
