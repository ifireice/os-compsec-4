2011.12.25.15.25.48

Задание 0. Ладно. Минусы я уберу, но output.txt тоже не нужно было оставлять
	в хранилище.

Задание 1. Нет, ну goto - это, конечно, не страшно. Но первый же
	goto EndReadFile вполне можно заменить на break. И надо бы это сделать.

	Но вот настоящие замечания:

	(1) А что будет, если строка будет длиннее 1000 байтов? Это суровый
		баг у Вас с переполнением буфера на пару минусов.

Задание 2. Я так понимаю, что никаких изменений в коде? И всё равно остаются
	вопросы:

	(1) Зачем считать по модулю 511, если можно считать по модулю 512, что
		намного эффективнее. У Вас же, в общем-то, не получается
		экономии одного байта на этом: Вы всё равно считываете его,
		просто в другую переменную. Ну, а за счёт более сложных
		алгоритмов на код память тоже расходуется. 

	(2) По-прежнему, Вы ищете только одну сигнатуру.

	(3) Существуют же функции fread и fwrite.

	(4) Нужно добавить дизассемблированный загрузочный сектор в хранилище.

Задание 3. Не понятно, чем Вам так tasm нравится? Очень же старый ассемблер,
	который специально предназначен для программирования под DOS и
	Windows, а совсем не для системного программирования. Но раз вам
	нравится пересчитывать адреса... Ладно.

	Но возникает вопрос, а зачем Вы тогда пишете так:

		lea si, buf
		add si, 7b00h

	вместо того, чтобы писать так:

		lea si, [buf + 7b00h]

	Ну и минусы

	(1) Нужно сделать CRC32

	(2) И что за магические циферки Вы исправляете в buf?

	(3) Нужно же передавать управление на загружаемый код, а не просто
		распечатывать данные.

2011.12.05.15.58.12

Без изменений.

2011.12.03.10.27.17

Задача 0.

Много минусов за каждый файл не относящийся к исходным текстам. Зачем их
включать в хранилище? Во-первых, они занимают много места не понятно, с какой
целью, потому что просто получаются из исходных текстов. Во-вторых, с высокой
вероятностью не будут работать на машине другого человека: зачем мне
.exe-шник, если у меня Linux, и зачем мне

	$ file make_boot
	make_boot: ELF 32-bit LSB executable, Intel 80386

если у меня процессор архитектуры ARM? Всё это надо безжалостно вычистить из
хранилища, воспользовавшись командой filter-branch с опцией --tree-filter, о
которой можно прочитать здесь:

	http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/ch05.html	

Задача 1.

Воспользоваться для вывода stdout - это хорошо. Но...

(1) Нужно прочитать числа из всех файлов, и все их вместе отсортировать, а не
сортировать каждый файл отдельно.

(2) Некорректный формат одного из файлов не должен приводить к фатальному
сбою приложения: есть другие данные, с которыми надо работать.

(3) Ограничение в 100 чисел - это уж слишком для данной задачи. Программа
должна работать, пока ей хватает памяти для работы. Можно использовать realloc
для динамической подстройки размера буфера под количество чисел.

Задача 2.

(1) Почему у вас вычисления осуществляются по модулю 511? Почему не взять
512-байтовый буфер? Вычисления по модулю степени двойки гораздо эффективнее. И
вполне приемлемы для данной задачи.

И зачем такая сложная логика? Ведь, существует возможность отмотать файл назад:

	fseek(file, -512, SEEK_SET);

После того, как Вы обнаружите в потоке два байта сигнатуры.

(2) Почему предполагается в программе, что 0x55 0xaa может встретится только
в конце загрузочного сектора? Образ диска - штука большая и сложная и это
значение может оказаться на любом месте. Нужно найти всех кандидатов на
загрузочный сектор, а потом выбрать один из них, попробовав дизассемблировать.

(3) В хранилище нужно разместить листинг загрузочного сектора.

Задача 3.

Дополнительный плюс, конечно, за попытку воспользоваться системными вызовами
Linux. Но хотелось бы всё же, чтобы программа не только завершалась, но и
выводила результат вычисления на экран.
