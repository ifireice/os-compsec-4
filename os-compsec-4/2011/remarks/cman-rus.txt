2012.01.02.13.43.25

Задание 2. Кажется, обработка ошибок добавилась. Но проблема с посимвольным
	чтением-записью остаётся.

Задание 3. Ок.

Задание 4.

	(1) Жуть. Я неверно 100 раз прочитал выражение:

		int cou = ((1<<size) - 1)/(1<<sT)+1;

		Стиль записи без пробелов нужно использовать правильно. Пробелы
		в таком стиле пропускаются для того, чтобы подчеркнуть
		приоритет операций и показать, каков порядок выполнения: чем
		теснее текст, тем операции раньше выполняются. Поэтому я на
		автомате долго и упорно читал эту строчку так:

		int cou = ((1 << size) - 1) / ((1 << sT) + 1)

		Форматирование надо использовать аккуратно - оно не просто так,
		а один из способов придания смысла выражениям. Написали бы так:

		int cou = ((1<<size)-1)/(1<<sT) + 1

		я бы сразу понял. Ладно. Минус отменяется.

	(2) Но по-прежнему это не умножение матриц, хранящихся по квадратикам.
		Вы верно говорите, что чем реже окна меняются, тем лучше - это
		повышает локальность кода. Но проблема в том, что при хранении
		матриц по строкам, как у Вас, это окно, всё равно,
		будет разбросано по по разным страницам: элементы b[k][j] и
		b[k + 1][j] будут записаны на разных страницах.

		То, что у Вас написано - это оптимизация по использованию кэша,
		и это тоже хорошо, но хотелось бы именно оптимизации для TLB.

		Смысл этого задания был в том, что можно оставить сам цикл
		прохода по матрицам: for(i, j, k ...) прежним, линейным, а
		изменить лишь способ индексации элементов, и посмотреть, как
		это скажется на производительности.

		Можно это совместить с Вашей оптимизацией, тогда будет ещё один
		плюс и программа станет работать быстрее.

Задание 6. сс у меня есть, но это у меня clang, а у него целевая архитектура
	задаётся иначе. Это надо учитывать, когда makefile-ы для системных
	вещей создаются. LGDT ошибок никаких не вызывает - это просто загрузка
	некоторых специальных регистров процессора. Речь шла о необходимости
	проверить результат загрузки сектора. Вот.

	(1) Вы по-прежнему весьма суровы с флагом прерываний. На время
		работы с bios их можно и разрешить. Там же таймер тикает,
		за ним bios'у нужно аккуратно следить.

		Вообще, все критические секции (код, который выполняется
			гарантированно непрерывно) должны быть как можно более
			короткими.

Задание 7.

	(1) Это плохая идея - несколько раз пытаться одну и ту же секцию
		в LD описать. Потому что у меня, например, это не работает:

		ld --oformat elf32-i386 -m elf_i386 -Tlink.ld -o kernel f.o main.o monitor.o common.o descriptor_tables.o isr.o interrupt.o gdt.o go32.o
		ld: section .eh_frame loaded at [0000000000009000,00000000000092c3] overlaps section .text loaded at [0000000000009000,0000000000009fff]

		потому что ld вычисляет положение для .eh_frame после обработки
		первой секции .text, а потом вы на это место пытаетесь
		разместить снова секцию .text.

		Это первое. Второе: ничего же не поменялось... Всё ещё стоит
		в программе call 0x9000, то есть, адресами Вы управляете
		по-прежнему вручную, только теперь ещё более сложным образом.
		В программах должно быть как можно меньше магических чисел и
		адресов - такова общепрограммистская мудрость. Поэтому,
		хотелось бы здесь видеть

			call main

		И просто одну секцию .text, в которую собирались бы все
		модули.

Задание 8. Я так понимаю, оно всё ещё не доделано?

2012.01.01.15.49.03

Задание 0. Ну вот, опять :( Куча бинарных файлов. Это добавляет много сложности
	в попытки разобраться в Ваших исходников. Ну в конце концов, существует
	же .gitignore:

		http://help.github.com/ignore-files/

	Вот сколько минусов:

		$ ls {task7,task8}/{*.o,*.out,load*,kernel} | wc -l
		ls: cannot access task8/*.o: No such file or directory
		ls: cannot access task8/*.out: No such file or directory
		ls: cannot access task8/kernel: No such file or directory
		13

Задание 7. В принципе, не плохо. Но:

	(1) Хотелось бы, чтобы go32.asm линковался вместе с другими модулями на
		общих основаниях. При текущем решении приходится управлять
		двумя адресами: откуда начинается go32 и kernel. Пусть этим
		занимается линковщик.

	(2) Всё же хотелось бы GPF

Задание 8. Оно, кажется, не доделано?

2011.12.27.16.09.41

Задание 1. Да, он нормально работает с одним файлом. Но, получается, что
	уничтожается содержимое файла последнего. Надо тогда выводить сообщение
	большими буквами: ФАЙЛ X БУДЕТ ПЕРЕЗАПИСАН и вопрос пользователю
	задавать, хочет он этого или нет.

	Но обычно не принято исходные файлы перезаписывать, если это явно
	как-то не указано при помощи специальной опции, типа --force. Да и
	защищён исходный файл может быть от записи.

	Вот какая куча недостатков. Ну да ладно. Надеюсь, Вы это осознаете и
	больше так делать не будете.

Задание 2. Ладно, не плохо. Но...
	
	(1) Perl же умеет читать из файлов целые куски и куски же записывать:
		read/write. Посимвольно - это не очень хорошо. Или даже очень
		не хорошо.

	(2) Ошибки же! Бывают не только при открытии и закрытии.

Задание 3.

	(1) Надо передать управление не код.

	(2) Проверка на тип процессора не правильно сделана. Вы проверяете,
		на самом деле, в какую именно инструкцию ассемблер
		оттранслировал pushfd. Это может быть либо 9C, либо 66 9C
		(66 префикс для определения размерности). Но процессор
		может и не знать инструкции 66 9C, и она пошлёт его в аут.
		Правильная проверка должна быть примерно такая:

		;--------i8086,i286------------
		pushf
		pop ax
		and ax,0F000h
		cmp ax,0
		je i286
		cmp ax,0F000h
		je i8086
		;------i386---------------------
		pushfd


Задание 4. Хорошо то, что есть тесты, и что всё в одном файле, и матрицы
	одинаковые. Но всё же.

	(1) А почему cou так странно расчитывается? Допустим, если sT = 0,
		то есть, размер тайла 1x1, то получится нечто некорректное.

	(2) А является ли описанный алгоритм умножением матриц? Можно же
		посчитать количество итераций, затрачиваемых на вычисление
		одного элемента в матрице C.

		Для разных x и у всегда будут разные x1 и y1, значит, это
		количество определяется только тремя внутренними циклами.

		Для разных i и j тоже будут всегда разные элементы c
		рассматриваться. Значит, количество операций определяется
		диапазонами для i2 и il. А они в произведении не дают 1 << size.

		Кроме того, смысл хранения по tile-ам он в том, чтобы при
		переходе через строку матрицы b оставаться в том же самом
		линейном небольшом участке памяти, а у Вас всё-равно будет
		переход через длинную строку матрицы b.

		Вообще, проще всего всю эту арифметику пересчитать, если
		предполагать, что элемент матрицы A(i,j), где сама матрица
		имеет вид

			A[N/tn][M/tm][tn][tm] // тайл размером tn на tm

		находится по адресу

			A[i/tn][j/tm][i%tn][j%tm]

Задание 6. То же самое замечание о флагах для gcc (куда он делся?) и ld

	(1) Обработка ошибок

	(2) Makefile

	(3) Только сейчас заметил - не сделан cli для перевода процессора в
		защищённый режим.

Задание 7. Повторюсь. Видимо, эффекта нет от того, что компилятор просто не
	вставляет в код инструкции для вычисления 

		int a= 2/0;

	Но можно уже и недочёты упомянуть.

	(1) Нужно использовать загрузчик из задания 3.

	(2) Всё-таки, для этой задачи уже надо бы использовать настройку
		компилятора Си на верную архитектуру процессора. В задании 6
		это простительно, там мало всего, и я могу написать их для
		проверки вручную. Но здесь много модулей, и это должно быть
		автоматизировано. Для GCC нужно бы дописать

			gcc -m32 -march=i386

		для LD:

			ld --oformat elf32_i386 -m elf_i386

	Кроме этого пока не понятно, но учтите, что в interrupt.s немного
	неверная модель описана происходящего. При переходе из Ring0 в Ring0,
	как в случае для этой задачи, SS:ESP в стек не записываются. Это надо
	учесть.

2011.12.22.13.38.16

Задание 0. Оно связано с искусством владения Git, поэтому переношу сюда
	минусы за бинарные файлы в хранилище, которые надо бы почистить.

	(1) task2/bin123

	(2) task3/1, task3/asm/1, task3/asm/2

	(3) task4/cw

Задание 1. 

	(1) А почему у вас i равное argc-1 обрабатывается в цикле?

	(2) И всё то же замечание про try-catch внутри цикла.

Задание 2.

	(1) По-прежнему в программе предполагается, что заканчивающийся на 0x55
	0xaa сектор может быть лишь один в образе диска. Но это может быть и не
	так.

Задание 3. Уже лучше. Но, как-то, очень сурово и хардкорно у Вас. Не знаю,
	не уверен, что в данном случае эта хардкорность оправдана. С одной
	стороны, мне хочется за Ваше решение поставить дополнительный плюс, а с
	другой - нет от него ощущения надёжности. Наверное так: если баллов
	хватать не будет до автомата, то поставлю здесь Вам плюс. А пока - нет.

	Ну. И есть недочёты, с которыми остаётся справится

	(1) Надо посчитать CRC32.

	(2) Надо не просто напечатать загруженный текст, а передать управление
		на загруженный код.

Задание 4. У меня только обычное умножение матриц. Потерялся второй файл?

Задание 5. Хорошо.

Задание 6. Замечательно. Только вот:

	(1) Makefile всё же надо бы сделать подеревяннее. В том смысле, что
		надо бы не в одном правиле всё собирать, а по кусочкам. Тем
		более, у Вас же в "f" есть неплохой пример.

	(2) Обработка ошибок

Задание 7.

2011.12.05.14.01.35

Без изменений.

2011.12.02.12.08.42

Задача 1.

(1) А что если в команде будет указано только имя программы и всё?
А если будет указан только один файл? Надо аккуратнее разобраться с argc.

(2) Разве есть необходимость использовать в этой задаче глобальную память?
vector и vector::iterator - это же, в общем-то, ссылочные объекты. Стек на них
не будет сильно расходоваться.

(3) Цикл в строках 23-37 не очень хорош. Потому что, если память закончится,
то бесполезно повторять попытки записать новое значение в вектор, ведь,
в свободное место магическим образом не появится. В итоге, будут выданы
100500 сообщений об ошибке.

Кроме этого, try-catch внутри цикла - это не самое эффективное решение. Тут
разумнее весь цикл разместить внутри try-catch (с философских позиций нужно же
ловить исключительные ситуации в процессе работы всего алгоритма, а не
какой-то мелкой его части).

(4) Это не замечание, а просто такой вопрос: Вы уже второй, кто использует
stdio при программировании на С++, почему? Чем плох iostream?

Задача 2.

(1) IDA - это круто, конечно. Но полученный ассемблерный код явно некорректный.
Ведь, загрузочный сектор - это 16-битовый код, а в полученном Вами листинге
встречаются инструкции типа:

	mov esp, <32-битовое значение>

Так не должно быть.

(2) Не совсем корректно предполагать, что во всём образе диска
последовательность 0x55 0xaa встретится только один раз и только для
загрузочного сектора. Нужно отыскать все такие сигнатуры.

Задача 3.

(1) Эх, я понимаю, конечно, что Perl, но, ведь, это плохая практика писать if
(тем более важный, который относится к анализу входных данных) в конце
выражения. Минус за это, код должен быть читаемым даже в редакторе без
подсветки синтаксиса.

(2 и 3) Ух. Когда вы занимаетесь накладыванием заплаток на бинарные данные,
нужны комментарии. Что такое l1 и l2? Почему они записываются в два разных
места? Почему длина не сохраняется? Почему l1 и l2 - это результаты деления
с остатком на 256? Неплохо бы было это всё прокомментировать. И добавит ещё
ассемблерный код для используемого загрузочного сектора.

Задача 4. Здесь вот точно не нужно бинарные файлы включать в хранилище.  Надо
почистить. Смотрите про использование filter-branch --tree-filter в руководстве
Git Magic

	http://dl.dropbox.com/u/281916/delete/book.pdf
