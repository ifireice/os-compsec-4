2012.01.13.23.56.43

Я верно понимаю, что изменений по предыдущим заданиям нет?

Задание 7. Так, во-первых, не требовалась же качественная реализация rand. А
	просто хоть какая-то. Кроме того, glibc же есть в исходниках и
	комментатриях. Например, описание random есть здесь:

		http://www.mscs.dal.ca/~selinger/random/

	По вопросу с прерываниями. Можно же взять ассемблер и посмотреть, что
	у всех видов iret одинаковый код: CF. Дело не в этом.

	И есть у меня ощущение, что Вы не особо верно загружаете IDT. Почему
	ebx + 2?

	Плюс к этому есть ещё один минус.

	(1) Не компилируется Ваш код на 64-битной системы

		$ sh 1.sh 
		In file included from /usr/include/features.h:382:0,
		from /usr/include/stdlib.h:25,
		from 1.c:7:
		/usr/include/gnu/stubs.h:7:27: fatal error: gnu/stubs-32.h: No such file or directory
		compilation terminated.

		stubs-32.h - это определения для типов, вроде uint32_t и тому
		подобных радостей. У Вас эти определения сделаны вручную, что
		не так уж и плохо, но этот файл тянется за stdlib, от которой
		надо бы избавится. Мы же пишем как бы ядро OS, там не может
		быть libc.


2012.01.11.18.18.25

Общее такое замечание ко всем исходным текстам. Существует typedef специально
для определения типов, define для этого лучше не использовать, потому что
могут возникнуть проблемы, когда, например, в библиотеке уже определён тип
uint, а препроцессор будет сносить этой библиотеке логику, заменяя его на
нечто неожиданное.

Если вы используете define для выражений, то эти выражения надо брать в скобки,
потому что нет гарантий, что приоритеты оператора внутри такого выражения
перевесят приоритеты операторов, которые стоят снаружи от обращения к
макросу.

Задание 1. ОК.

Задание 2. ОК.

Задание 3. Вроде, лучше. Но

	(1) Ошибки. Если вот это
		
		read=fread(buffer, 1, 30720, fp);

		вернёт -1, будет очень весело дальше. Если что-то не допишется
		в файл, тоже будет праздник отладки. И что будет, если сектора
		не загрузятся? И так далее.

	(2) Не все x86 процессоры могут выполнять 32-битовый код. Если Вы его
		используете, то нужно сначала проверить, что процессор на
		это способен. Проверить можно таким кодом:

		;--------i8086,i286------------
		pushf
		pop ax
		and ax,0F000h
		cmp ax,0
		je i286
		cmp ax,0F000h
		je i8086
		;------i386---------------------

Задание 4. Оно, конечно, не было указано, как именно следует инициализировать
	матрицы, но захотелось напомнить, что memset работает с байтами.
	Это не минус, просто напоминание. Минусы вот:

	(1) Ваш код совсем не умножает матрицы.

	(2) Плитка может быть любого размера, и она является просто
		прямоугольной таблицей из элементов матрицы, которая составлена
		из этих прямоугольников. То есть, структура примерно такая:

			A[N/TX][M/TY][TX][TY] // для простоты всё кратное.

		Если TX = TY = 1, то получаем обычную матрицу, хранимую
		по строкам.

		У Вас же как-то странно получается, когда T = 1. Если
		подставить сюда:

			buf[ T*(i/T) + j/T ] [T*(i%T)+j%T]

		То получится

			buf[i + j][0]

		Не очень похоже на матрицу, потому что для разных i и j
		могут ([3;5] == [5;3]) выбираться одинаковые элементы.

		Оно у Вас, вроде, должно работать, для тех размеров, которые Вы
		используете, но хотелось бы более общего алгоритма, чтобы
		можно было произвольно эти размеры менять.

		Плюс я не понял Ваш комментарий. Смысл всего этого плиточного
		подхода как раз в том, чтобы при смене номера строки матрицы
		(i) не приходилось перепрыгивать на другую страницу памяти,
		и в формуле, которая у Вас в программе так и происходит. Но
		формула, которая в readme.txt, совсем не такая. И как Вы от
		одной перешли к другой, для меня загадка.

Задание 6. Нормально, но в следующий раз надо учитывать, что компиляция может
	происходить совсем не на той системе, о которой Вы подумали. Поэтому,
	нужно достаточно точно указывать для gcc и ld целевую архитектуру.
	При решении 7-ой задачи обязательно нужно будет использовать ключи:

		gcc: -m32 -march=i386
		ld: -m elf_i686 --oformat=elf32-i386

	(1) Эх... Лихие люди в Вашей группе. Вот переводите Вы роцессор в
		защищённый режим, структуры у него никакие не настроены,
		сегменты тоже, адреса - каша. И тут прилетает Вам прерывание.
		И всё. Ядерный реактор взорвался.

		Почему cli не используется на время смены режима работы
		процессора?

		Ядерный реактор в опасности. Это двойной минус.

2012.01.01.19.18.16

Без изменений.

2011.12.27.19.12.14

Без изменений

2011.12.25.15.25.48

Задание 0. Ладно. Минусы я уберу, но output.txt тоже не нужно было оставлять
	в хранилище.

Задание 1. Нет, ну goto - это, конечно, не страшно. Но первый же
	goto EndReadFile вполне можно заменить на break. И надо бы это сделать.

	Но вот настоящие замечания:

	(1) А что будет, если строка будет длиннее 1000 байтов? Это суровый
		баг у Вас с переполнением буфера на пару минусов.

Задание 2. Я так понимаю, что никаких изменений в коде? И всё равно остаются
	вопросы:

	(1) Зачем считать по модулю 511, если можно считать по модулю 512, что
		намного эффективнее. У Вас же, в общем-то, не получается
		экономии одного байта на этом: Вы всё равно считываете его,
		просто в другую переменную. Ну, а за счёт более сложных
		алгоритмов на код память тоже расходуется. 

	(2) По-прежнему, Вы ищете только одну сигнатуру.

	(3) Существуют же функции fread и fwrite.

	(4) Нужно добавить дизассемблированный загрузочный сектор в хранилище.

Задание 3. Не понятно, чем Вам так tasm нравится? Очень же старый ассемблер,
	который специально предназначен для программирования под DOS и
	Windows, а совсем не для системного программирования. Но раз вам
	нравится пересчитывать адреса... Ладно.

	Но возникает вопрос, а зачем Вы тогда пишете так:

		lea si, buf
		add si, 7b00h

	вместо того, чтобы писать так:

		lea si, [buf + 7b00h]

	Ну и минусы

	(1) Нужно сделать CRC32

	(2) И что за магические циферки Вы исправляете в buf?

	(3) Нужно же передавать управление на загружаемый код, а не просто
		распечатывать данные.

2011.12.05.15.58.12

Без изменений.

2011.12.03.10.27.17

Задача 0.

Много минусов за каждый файл не относящийся к исходным текстам. Зачем их
включать в хранилище? Во-первых, они занимают много места не понятно, с какой
целью, потому что просто получаются из исходных текстов. Во-вторых, с высокой
вероятностью не будут работать на машине другого человека: зачем мне
.exe-шник, если у меня Linux, и зачем мне

	$ file make_boot
	make_boot: ELF 32-bit LSB executable, Intel 80386

если у меня процессор архитектуры ARM? Всё это надо безжалостно вычистить из
хранилища, воспользовавшись командой filter-branch с опцией --tree-filter, о
которой можно прочитать здесь:

	http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/ch05.html	

Задача 1.

Воспользоваться для вывода stdout - это хорошо. Но...

(1) Нужно прочитать числа из всех файлов, и все их вместе отсортировать, а не
сортировать каждый файл отдельно.

(2) Некорректный формат одного из файлов не должен приводить к фатальному
сбою приложения: есть другие данные, с которыми надо работать.

(3) Ограничение в 100 чисел - это уж слишком для данной задачи. Программа
должна работать, пока ей хватает памяти для работы. Можно использовать realloc
для динамической подстройки размера буфера под количество чисел.

Задача 2.

(1) Почему у вас вычисления осуществляются по модулю 511? Почему не взять
512-байтовый буфер? Вычисления по модулю степени двойки гораздо эффективнее. И
вполне приемлемы для данной задачи.

И зачем такая сложная логика? Ведь, существует возможность отмотать файл назад:

	fseek(file, -512, SEEK_SET);

После того, как Вы обнаружите в потоке два байта сигнатуры.

(2) Почему предполагается в программе, что 0x55 0xaa может встретится только
в конце загрузочного сектора? Образ диска - штука большая и сложная и это
значение может оказаться на любом месте. Нужно найти всех кандидатов на
загрузочный сектор, а потом выбрать один из них, попробовав дизассемблировать.

(3) В хранилище нужно разместить листинг загрузочного сектора.

Задача 3.

Дополнительный плюс, конечно, за попытку воспользоваться системными вызовами
Linux. Но хотелось бы всё же, чтобы программа не только завершалась, но и
выводила результат вычисления на экран.
