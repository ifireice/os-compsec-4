2012.01.01.19.16.33

Без изменений

2011.12.27.18.28.04

Задание 3.

	(1) Ошибки же! Ну Вы же можете смотреть, что я пишу в комментариях
		другим студентам. Надо обрабатывать ошибки. В данной задаче,
		раз логика у неё непростая, можно подойти с такой схемой:

			if(error)
			{
				printf("ERROR\n"); // тут разумное сообщение
				exit(1); // завершение процесса
			}

	(2) Нужно, перед тем, как использовать 32-битовые регистры убедится,
		что процессор их поддерживает. Проверить это можно примерно
		так:

		;--------i8086,i286------------
		pushf
		pop ax
		and ax,0F000h
		cmp ax,0
		je i286
		cmp ax,0F000h
		je i8086
		;------i386---------------------

		Или использовать 16-битовый код для вычисления CRC32 - это
		выгоднее по объёму кода будет.

		Но любой вариант сойдёт.

2011.12.22.15.46.26

Задание 0. Чистка прошла успешно :) 
Задание 1. Неплохо

Задание 2. Логика хорошая у программы. Но:

	(1) Обработка ошибок же.

	(2) Можно использовать fread и fwrite для чтения блоков данных из
		FILE.

2011.12.05.14.03.11

Прочитайте, пожалуйста, замечания о том, как следует вычистить файлы
из хранилища, которые написаны в remarks/scraftworld.txt

2011.12.02.13.36.23

Задача 0.

(1  и 2) В хранилище не должно быть бинарных файлов. Удалите их при помощи
команды Git filter-branch и опции --tree-filter. Подробности здесь

	http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/ch05.html

А пока по минусу за каждый .exe.

Задача 1.

Это хорошо, что вместо открытия дополнительного файла на запись, вы
выводите результат на stdout, оставляя работу по открытию файла оболочке. Это
дополнительный +. Но минусов тоже много.

(1 и 2) Смотрите замечания о необходимости осторожного обращения с аргументами
и про вложенный в цикл try-catch в cman-rus.txt

(3) Разве fscanf возвращает меньшее нуля значение в случае, когда ей не
удалось прочитать данные в соответствии с указанным форматом?

(4) А что если в векторе накопилось больше 1 << 32 чисел? Через это

	i < (int)numbers.size()

Вы можете потерять информацию.

Задача 2.

(1) Что-то я не осознал... Такое ощущение, что вы просто копируете первые
512 байтов образа диска. Но этот образ может быть устроен очень сложно, и не
обязательно загрузочный сектор может располагаться в начале этого образа.

(2) Нужно учесть, что меток 0x55 0xaa в файле может быть несколько.

(3) Нужно обрабатывать ошибки. putc и getc могут вернуть значения, говорящие
об ошибках доступа, а вы их будете игнорировать в вечном цикле?

(4) Загрузочный сектор для x86 должен начинаться с 16-битового кода, а у
вас прямо в самом начале

	 mov     esp, 0E5897BECh

Такого быть не должно (особенно загрузки 32-битовых значений).
Дизассемблирование прошло некорректно.
