2011.05.18.16.04.58

Задача 2.

2011.05.26.12.49.12

Задача 5 и 5.(+1). Не компилируются обе с одинаковой ошибкой:

	$ gcc -O3 dekker_mfence.c -D_GNU_SOURCE -o dmf -lrt -lpthread	
	dekker_mfence.c: In function ‘proc1’:
	dekker_mfence.c:14:1: error: parameter name omitted
	dekker_mfence.c: In function ‘proc2’:
	dekker_mfence.c:41:1: error: parameter name omitted

Задача 5. Ещё проблема: она зависает - почему?

2011.05.28.15.07.30

Задача 3. Ух... Множество вопросов.

1. Зачем постоянно переконфигурировать терминал? Но это ладно. Терминалами
мы не занимались, хто Ваше личное творчество. Однако на будущее: не нужно так
поступать. Это и не эффективно, и может к ошибкам приводить.

2. Вообще совсем не понятны рассуждения о том, зачем Вам понадобился mutex.
Кэши, вообще-то, синхронизируются автоматически. А если Вам нужно было
убеждаться, что информация о записи в переменную дошла до другого процессора,
то для этого есть mfence.

3. Эх. perror тоже пишет в stderr. Поэтому нет смысла писать

	if(fprintf (stderr, "%s\n","i can't unlock mutex")==-1) {
		perror(printfErrorMessage);
	}

Если первое не сработало, то второе тоже не сработает. И вообще у Вас код
очень сложный, а эти конструкции, одинаковые, постоянно повторяются.
Почему нельзя это всё было в виде отдельной функции оформить?

4. Ну вот право же. Зачем такая гиперсложная система? Нити, сигналы, активные
ожидания. К чему это всё? Это же пустое усложнение. А специально усложнять и
без того сложные системы - это разве разумно? Зачем Вам это?

Плюс куча ошибок в этих черезмерно усложнённых потоках данных. Вот это Вам
зачем?

	key='q';
	lock=ask;
	pthread_exit(&bad);

Это типа такой изящный способ завесить второй поток, который крутится в
while(lock == ask)? И вообще всю программу, потому что join не завершится? Так
написали бы сразу же while(true); и не мучались бы.

5. А сигналы? Эх. Отдельная песня. Вот делаете вы pthread_exit, а сигнал
оставляете старым. Программа висит, таймер тикает, пересчёт вызывается,
загрузка процессора 100% - это вы специально решили помочь системным
администраторам сварить кофе на процессоре?

6. И я что-то не вижу доказательства того, что обработчик сигнала увидит,
что lock изменился. Каким образом Вы гарантируете, что сигнал не вызовется,
во время того, что вы делаете

	lock = current

и что

	if(next == lock)

Будет отражать тот ход выполнения, который Вы запланировали? Почему lock
обработчик увидит обязательно вот этот, изменённый, а не старый? И не снесёт
тем самым тот буффер, который печатается в данный момент.

7. Из-за излишней сложности, вероятно, в программе ещё куча ошибок. Но сначала
исправьте хотя бы эти. И заметьте, я тут пока вообще ничего не написал про
активное ожидание. Кроме тех слов о гремучей смеси кучи различных подходов
в том месте, где хватило бы одного из них.
