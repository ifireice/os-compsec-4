2012.01.17.02.05.04

Без изменений

2012.01.14.01.10.43

Без изменений

2012.01.11.20.31.16

Без изменений.

2012.01.01.19.18.44

Без изменений.

2011.12.27.19.21.41

Задание 2. Хорошо.

2011.12.25.17.16.29

Задание 2. В принципе, не плохо. Но вот минус:

	(1) Это как бы, существенно, поэтому минус двойной. Потому что, а вдруг
		candIndex станет больше 999? Будет всякая порча памяти.
		Тут можно сделать так:

			char * tail = new char[sizeof(candIndex) * 2 + 1];
			itoa(++candIndex, tail, 16);

		По крайней мере, не будет ошибок с доступом к памяти.

2011.12.05.16.01.24

Задача 1.

Хорошо. Минусы все убрались. Но можно было бы всё же и более системно. С другой
стороны - работает.

2011.12.03.14.34.13

Задача 0.

Задача 1.

Дополнительный плюсик за то, что осторожно обращаетесь c sort. Ну и все
случаи разобраны сразу. Это хорошо. Это ++. Но...

(1) А почему Вы никак не учитываете, исключения, выброшенные sort-ом? Вдруг
не выйдет отсортировать данные. В этом случае не нужно пытаться записать
данные.

(2) Слишком сложно. Это в минус не пойдёт, ведь, задача решена, но всё таки,
слишком сложно. В ReadFromFile вполне можно было бы вынести однотипный код
в одно место. А Sort и Write можно было бы обработать в одном try-catch блоке.

(3) Наверное, это минус. Хотя, задача и решена. Если Вы используете Си++ и его
объектные особенности, то вполне можно было бы воспользоваться RAII. Зачем
писать

	try {
		fin.open(filename)
		if(!fin.eof())...
	}
	catch(...) {
		// process exception
		fin.close();
	}

Если можно просто:

	try {
		ifstream fin(filename);
	}
	catch(...) {
		// process exception
	}

Обычно, RAII существенно упрощает код.
