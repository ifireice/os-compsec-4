2011.03.26.12.24.27

В задаче 5, про матрицы. А Вас не смутило, что времена почти одинаковые получаются, да ещё и очень маленькие? clock возвращает микросекунды, то есть, у вас код работал всего 5 миллисекунд. Не слишком ли быстро? Объясните, пожалуйста, почему так.

В задаче 4, про защищённый режим. А почему регистр ss у Вас не настраивается никак? Это же важный сегмент - сегмент стека.

В задаче 2, кажется, ничего не изменилось в ней. fscanf, по-прежнему, некорректно обрабатывается.

---

Задача 4. Аналогичное замечание.

Задача 3. Нужно проверять ошибки. Сектор может и не загрузится. Проверяйте AH на равенство нулю - это код успешного завершения процедуры загрузки.

Задача 2. Нельзя так проверять коды возврата функций типа fscanf. Они могут вернуть ноль или отрицательное значение в случае ошибки. !fscanf в последнем улчае будет false, и нужная ветка не сработает.

2011.05.18.17.38.45

Задача 2. Но fputs же тоже работает через библиотеку Streams (которая про
FILE*, printf и прочие stdio-фукнкции). Это тоже не signal-safe вызов. Если
делать так, как делаете Вы, то нужно выполнять операцию write(1, ...). Кроме
этого: её величество, обработка ошибок, sigaction может завершиться с ошибкой.

2011.05.26.15.00.52

Задача 4.(-1) Всё замечательно и лаконично. Только отформатировать бы
текст не помешало. И ещё претензия: а что если read вернёт в res отрицательное
значение? Write-у будет очень плохо.

Задача 5.(+1) Как-то mfence у Вас не во всех необходимых местах расставлен. И
с volatile тоже проблема. В итоге, программа просто зависает:

	$ gcc -D_GNU_SOURCE -O3 -lpthread dekker.c -o dkr && time ./dkr
	^C
	real    0m36.093s
	user    1m11.859s
	sys     0m0.010s

Я уж не стал дольше ждать.

2011.05.28.17.01.04

Задача 5.(+1). Так. Уже лучше, появились volatile в нужных местах. И программа
теперь уже не зависает, что есть шаг вперёд.

Но пока ещё она не выдаёт правильный результат:

	$ gcc -O3 -D_GNU_SOURCE dekker.c -o dkr -lpthread && ./dkr
	19998124

Вам нужно задуматься, зачем нужен mfence, и в достаточном ли количестве он
расставлен в алгоритме Деккера.
