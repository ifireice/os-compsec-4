SCraftworld

	0 ++; 1 +---; 2 +--; 3 ++---; 4 +--; 5 +-


Задачи. Семестр 1.

	0. Нужно зарегистрировать аккаунт на GitHub и опубликовать в нём
		программу 'Hello world'.

	1. Нужно написать программу, которой при запуске в качестве нескольких
		первых аргументов передаются имена исходных файлов, в которых,
		предположительно, должны быть записаны числа в текстовом виде,
		разделённые пробельными символами (так что, fscanf(f, "%d", &x)
		должен читать их последовательно). В качестве последнего
		аргумента программе передаётся имя файла, в который нужно
		записать прочитанные из исходных файлов и отсортированные
		числа.

		Следует учесть, что...

			1.1. Некоторые имена файлов могут быть указаны неверно.

			1.2. В некоторых файлах могут быть данные отличные от
				списков целых чисел в текстовом представлении.

		Программа должна по возможности (а ещё может не хватать
		памяти) отсортировать числа из корректных файлов.

	2. Это задание заключается в том, что нужно создать образ виртуального
		диска для эмулятора QEMU, на который нужно установить ОС Plan9,
		естественно, загрузив её из образа CD формата iso9660,
		доступного по адресу:

			http://0xfb.imm.uran.ru/tmp/plan9.iso.bz2

		Затем, используя знание о том, что загрузочный сектор на диске
		имеет размер 512 байтов и оканчивается байтами 0x55 0xaa, нужно
		написать программу, которая найдёт этот загрузочный сектор
		в образе виртуального диска с установленной Plan9 и запишет
		его в некий файл. В результате выполнения этого задания
		нужно сдать программу поиска загрузочного сектора в образе
		диска и дизассемблированный загрузочный сектор (для этого
		можно использовать дизассемблер из пакета ассемблера NASM).

	3. Следует написать программу, которая по указанному ей файлу F создаёт
		новый файл I, который должен быть загружаемым (с загрузочным
		сектором) образом дискеты в QEMU. Загрузочный сектор должен
		быть устроен так, что он загружает данные файла F (которые
		размещаются на образе дискеты) и передаёт на них управление.
		При этом, при формировании файла I должна быть подсчитана
		контрольная сумма CRC32 от данных в файле F, а после загрузки
		этих данных, код загрузчика должен проверить эту сумму. И
		управление на данные (код - это тоже данные) файла F должно
		передаваться только в случае успешности загрузки и проверки
		CRC32, иначе, должна быть выдано сообщение об ошибке.

		Следует учесть, что...
			
			3.1. Так как за одно обращение к BIOS можно прочитать
				данные только с одной дорожки, то можно
				ограничится работой с F-файлами размером не
				больше 30 * 1024 байт, однако, следует помнить,
				что пользователь - лопух, и может указать
				программе более файл большей длины.

	4. Для оценки влияния страничной трансляции адресов на скорость работы
		программ следует сравнить скорости работы двух программ
		умножения матриц, которые можно обозначить R и T. Обе программы
		должны умножать матрицы одинаковых размеров, а отличие этих
		программ должно быть следующим.
		
		Программа R (rows) должна трактовать матрицы, как обычные
		двумерные массивы Си, расположенные по строкам. Напоминание:
		массив 'int a[X][Y]' содержит в себе X строк, каждая из которых
		содержит Y элементов. Строки располагаются в памяти друг за
		другом.  Поэтому переход между разными строками (от a[i][j] к
		a[i + c][j]) при достаточно длинных строках может привести к
		переходу между страницами.

		Программа T (tiles) должна трактовать матрицы, как
		расположенные в памяти плиткой (не путать с loop tiling).
		Расположение матрицы A плиткой (квадратной для простоты)
		размером TxT означает, что i:j элемент матрицы располагается
		в плитке с координатами (i/T):(j/T) на позиции (i%T):(j%T).
		Плитки располагаются в памяти друг за другом.

		При таком расположении переход от элемента i:j и к элементу
		(i + 1):j, и к элементу i:(j + 1) часто может быть осуществлён
		внутри одной плитки, и не приводить к смене страниц при
		обращении к памяти.
	
	5.
