2011.12.03.10.27.17

Задача 0.

Много минусов за каждый файл не относящийся к исходным текстам. Зачем их
включать в хранилище? Во-первых, они занимают много места не понятно, с какой
целью, потому что просто получаются из исходных текстов. Во-вторых, с высокой
вероятностью не будут работать на машине другого человека: зачем мне
.exe-шник, если у меня Linux, и зачем мне

	$ file make_boot
	make_boot: ELF 32-bit LSB executable, Intel 80386

если у меня процессор архитектуры ARM? Всё это надо безжалостно вычистить из
хранилища, воспользовавшись командой filter-branch с опцией --tree-filter, о
которой можно прочитать здесь:

	http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/ch05.html	

Задача 1.

Воспользоваться для вывода stdout - это хорошо. Но...

(1) Нужно прочитать числа из всех файлов, и все их вместе отсортировать, а не
сортировать каждый файл отдельно.

(2) Некорректный формат одного из файлов не должен приводить к фатальному
сбою приложения: есть другие данные, с которыми надо работать.

(3) Ограничение в 100 чисел - это уж слишком для данной задачи. Программа
должна работать, пока ей хватает памяти для работы. Можно использовать realloc
для динамической подстройки размера буфера под количество чисел.

Задача 2.

(1) Почему у вас вычисления осуществляются по модулю 511? Почему не взять
512-байтовый буфер? Вычисления по модулю степени двойки гораздо эффективнее. И
вполне приемлемы для данной задачи.

И зачем такая сложная логика? Ведь, существует возможность отмотать файл назад:

	fseek(file, -512, SEEK_SET);

После того, как Вы обнаружите в потоке два байта сигнатуры.

(2) Почему предполагается в программе, что 0x55 0xaa может встретится только
в конце загрузочного сектора? Образ диска - штука большая и сложная и это
значение может оказаться на любом месте. Нужно найти всех кандидатов на
загрузочный сектор, а потом выбрать один из них, попробовав дизассемблировать.

(3) В хранилище нужно разместить листинг загрузочного сектора.

Задача 3.

Дополнительный плюс, конечно, за попытку воспользоваться системными вызовами
Linux. Но хотелось бы всё же, чтобы программа не только завершалась, но и
выводила результат вычисления на экран.
