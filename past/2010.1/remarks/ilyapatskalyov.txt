2011.05.12.18.38.20

Задача 3. Почти всё замечательно и написано хорошо. Но вот блокировать расчётную нить на время вывода пользователю данных - не хорошо. А если он сидит через очень медленный терминал?

Задача 4. Сигналы же есть, зачем в цикле обрабатывать aio_error? За повторное использование кода плюс, но за копирование буферов (у Вас их всё-равно много, так почему бы просто не вести их учёт в критической секции?) и за этот цикл - два минуса.

Задача 5. Нити же не зря должны делать lock и unlock. Это же для доступа к общей переменной, а у Вас просто два счётчика, он один должен быть.

2011.05.26.13.25.15

Задача 4. Во-первых, ну зачем так сложно с получением подключений от
клиентов? Зачем опрос очереди, зачем отдельная нить вообще? Почему это
нельзя сделать в основной?

Но если по каким-то архитектурным соображениям Вам так делать не хочется,
то опрос через mutex - это зло: зачем тратить производительность системы
на то, чтобы постоянно будить нить, на захват мьютекса, на то, чтобы засыпать
и отслеживать время? Семафоры существуют, существуют pipe'ы:

	Можно перед чтением из очереди пытаться опустить семафор на единичку,
	и когда он будет опущен, уже точно быть уверенным в том, что очередь
	не пуста. А при записи в очередь, одного элемента, естественно,
	поднимать семафор на 1.

Во-вторых. delete this и new без try-catch -- это не есть очень хорошо. За это
я не буду минус минусовать, но всё же... C++ -- хардкорная штука, и надо эту
хардкорность в программах укрощать, иначе весь поток управления полетит в
Пампасы. Если не дальше.

В-третьих. Я не очень понимаю полёт Вашей мысли насчёт класса Aio. Он
странный очень. И я совсем никак не могу найти то место, где происходит
уменьшение countClient... О! Нашёл. Grep помог гиганту мысли. Но Илья! Нельзя
же так писать программы.

То есть, можно, конечно... Чисто технически. Но в наше время opensource и
copypaste нужно же и очитающих программу позаботится, а у Вас слишком уж поток
управления разбросан по разным местам.

Задача 4.(-1). И снова должен воскликнуть: ну какое usleep с активным
ожиданием!? Ну poll же для того и придуман, чтобы не нужно было устраивать этих
постоянных активных циклов опроса. Ну эта техника уже 22 года назад появилас,
зачем программировать как в каменном веке? БррРРр... И, ведь, главное, многие
из Вашей группы так пишут, кто Вас такому научил? Скажите мне ФИО этого
человека, я подвергну его сомнениям в профпригодности. poll умеет отслеживать
сразу кучу дескрипторов, пользуйтесь этим.

И ещё тут надо помнить о том, что read возвращает 0 при чтении из конца файла.

2011.05.28.16.56.03
