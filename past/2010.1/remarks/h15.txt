Задача 4. Ну вот... Куда jmp побежал-то? Сначала же верно было: сразу после включения protected mode. 

2011.01.26.12.41.58

Задачка номер 2. Всё равно. Подсчитывать количество чисел в файле, а потом заново его перечитывать - это плохой подход. И медленно, и не аккуратно, и не будет работать, если вместо файла подаётся поток данных, в котором чисел, потенциально, бесконечно много. На таком потоке Ваша программа просто зависнет.

Надо бы использовать realloc, как я и говорил.

4. Ну зачем там (38 строка) короткий jmp? Близкий переход не перегружает CS, а это то, что нужно сделать. И почему protected mode включается таким образом? Это legacy-инструкция, оставшаяся от i286. Оно работает, конечно. Но всё равно у меня вопрос: а почему не используется mov cr0, eax?

Кроме того. Нужно учитывать, что в некоторых прерываниях, процессор записывает код ошибки в стек. В этой задаче это не влияет на оценку, но вот в задачах про клавиатуру это надо учитывать.

Здесь же надо короткий jmp исправить на длинный: jmp новый-cs:xyz

5. Задача про линию кэша. Вы зря полагаете, что компилятор не сообразит (*a) разместить в регистре. Современные компиляторы очень много шаблонов знают и умеют их использовать. Поэтому и времена в результате у Вас получились близкие. Надо массив описать как volatile.

8. PIC. Всё же нужно бы иметь разные обработчики для разных типов прерываний. И ещё: а почему у Вас нет сигнала о завершении обработки прерывания PIC'у?

2011.05.18.15.11.03

Задача 2. Эх. Ну зачем так сложно? Кроме того, зачем опять эти циклы опроса?
Под Вашим приложением же целый UNIX с неплохими планировщиками, зачем
опрашивать состояние pipe, если можно просто уснуть на read?

	char chr;
	read(p0, 1, &chr);

Задача 3. У Вас же нити в программе, зачем всё делать через pipe? Да и вообще,
копирование в этой задаче - плохое решение проблемы по управлению буферами.
Тем более, в такой, построчной форме. Что будет, если терминал у пользователя
медленный? printf может начать работать очень долго, внутренний буфер pipe
будет переполнен, и временные рамки для расчёта будут нарушены.

А ещё вопрос: зачем Вы в клиентской нити 'щупаете' заполненность нити через
ioctl? Можно же просто read сделать. Вообще, экономия на системных вызовах -
это хороший тон.

2011.05.26.12.01.05

Задача 2. Надо бы сделать в цикле обработку сигналов

Задача 3. Ну какой while(LOCK != 0)? Не очевидно разве, что этот while в общем
случае может продолжаться неопределённо долго?  Кроме того, не очевидно разве,
что условие LOCK != 0 может выполнится в обоих нитях одновременно? И вся Ваша
схема синхронизации не сработает?

2011.05.28.11.26.45

Задачи 2, 3: без изменений.

Задача 4.(-1): Результат вот такого запуска:

	$ clang -O4 select.c -o slct
	$ (echo 123 && sleep 10s && echo 456) | ./slct 0
	123

разве является правильным? Почему 456 уже не считывается с stdin? Вообще,
задача же в том, чтобы ожидать возможности чтения на указанных дескрипторах,
пока такая возможность в принципе может возникнуть (файл не закончился: read
вернул 0, или сокет не закрылся). А пока оно открыто и работоспособно, нужно
ожидать данных, считывать их и выводить. При этом, желательно, выводить их в
перемешку, а не так, что целиком считываем всё, что есть, и только потом
переходим к работе со следующим дискриптором. Следует читать по BUF_SIZE из
каждого готового к чтению дескриптора, затем снова определять select'ом
множество готовых.

Задача 4. Во-первых, нужно было использовать aio.

Во-вторых, снова восклицание: ну какой к чёрту while(LOCK != 0)!?

В-третьих, а что будет, если к Вашему серверу будут подключаться клиенты раз
в полсекунды, каждый из которых будет забирать к себе Map в течении одной
секунды?

В-четвёртых, обработка ошибок.

2011.05.30.11.57.51

Задача 3. Алгоритм Деккера - это, конечно, креативный плюс. Но вот только в
нём же опять не хватает mfence-ов. Протестируйте вот именно этот вариант
на задаче, где просто увеличивается счётчик.

Ещё один недочёт - ну почему Вы делаете вывод на потенциально медленное
устройство в критической секции? Не хорошая это практикта. Разве сложно
в этой самой критической секции просто:

	Расчётная нить:
		1. Определить следующий свободный буфер.
		2. Взять целевой буфер, как новый текущий.
		3. Взять найденный свободный, как новый целевой.

	Клиентская нить:

		1. Взять текущий буфер и поставить галочку, что он занят.
		тут печать вне критической секции, затем снова в неё входим
		2. Убрать галочку с только что выведенного буффера.
