2012.01.11.20.36.55

Я так понимаю, в задания 1 - 6 никаких изменений?

Задание 7. Ну... В принципе, видно, что кое-что Вы и самостоятельно делали.
	Наверное, это плюс. Но есть и минусы:

	(1) А почему у Вас в isr_common_stub Вы указатель стека сдвигаете
		только на 4? Посмотрите формат стека при ошибке.

	(2) Вот настраиваете Вы процессор на защищённый режим, а тут Вам
		прилетает прерывание. Бабах - взрыв ядерного реактора, потому
		что в регистрах, которые управляют исполнением, каша. Это
		серьёзный баг, поэтому двойной минус.

	(3) А почему не выводится сообщение о прерывании? Надо бы это дело
		отладить.

2012.01.01.19.19.36

Без изменений.

2011.12.27.19.45.39

Без изменений. Моя вина, что Вы не увидели комментарии к задачам :( Прошу за
это прощения и прощаю, в качестве компенсации минусик за задачу 0.

2011.12.25.18.15.41

Задача 0. Тут, традиционно, минусы за ненужное в хранилище.

	(1) SortFiles/Debug/src/SortFiles.o

Задача 1. Хм. А почему Вы думаете, что Ваша реализация stdio лучше, чем
	в libc? Собственно, Вы сделали то же самое, что сделано для FILE. И
	почему populate названа так? Но это так. Важно, но не критично. Однако,
	есть и куча недочётов:

	(1) Нужно отсортировать содержимое файлов совместно, а не сортировать
		каждый файл отдельно.

	(2) Слишком много глобального контекста у Вас. Ладно, если бы было
		2-3 структуры, а у Вас куча переменных, не особо понятно, как
		связанных.
	
	(3) И почему предполагается, что open, или malloc, или fprintf, или
		fclose отработают без ошибок?

Задача 2. В приниципе, не плохо. Но:

	(1) A почему предполагается, что сектор в образе диска обязательно
		должен быть на границе в 512 байтов? Всяко разно может быть.

Задача 3. Вроде как, всё правильно, но не работает почему-то. Или я не
	понимаю, как она должна работать. Кажется, это Вы спрашивали про CRC32?
	Так вот вопрос, а какое CRC32 используется в Python? CRC32 бывают
	разные, с расчётом на разные порядки битов, с разными многочленами,
	и с "вычитанием -1" в конце. Нужно знать, какой имнно используется
	в Python, чтобы реализовать точно такой же.

	Плюс, наверное, поставлю, но и минус за то, что не работает.

Задача 4. Хорошо. Дополнительный + за GET_ADDR (но вернее было бы назвать это
	OFFSET). Но и минус:

	(1) Зачем столько магических чисел? Что такое 0x3f или 0xffffc0? А
		что если система не 32-битная? И почему 6?

Задача 5. Тоже неплохо. Но, ведь:

	(1) Нужно же сделать так, чтобы функция для печати вызывалась из
		кода на ассемблере.

Задача 6. Прочтите, пожалуйста, про опции для компилятора и линковщика у
	remarks/evelinka.txt
